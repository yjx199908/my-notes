### 单例设计模式

#### 模式定义：保证一个类只有一个实例,并且提供一个全局访问点

#### 场景：重量级的对象,不需要多个实例,比如线程池,数据库连接池

- 懒汉模式:延迟加载，只有在真正使用的时候，才开始实例化
  - 线程安全问题(给getInstance方法加synchronized修饰符，使得线程同步)

  - double check 枷锁优化

  - 使用volatile修饰引用符可以保证与此引用符相关的那段空间相关的指令不会发生重排序

  - ```java
    class LazySingleton{
        private volatile static LazySingleton instance;//volatile关键字可以保证与此引用相关的那段空间相关的指令不会发生重排序
    
        private LazySingleton(){
    
        }
    
        public static LazySingleton getInstance(){
            if(instance == null){
                synchronized (LazySingleton.class) {//线程加同步锁
                    if(instance == null){
                        instance = new LazySingleton();
                    }
                }
            }
    
            return instance;
        }
    }
    ```

- 饿汉模式:类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm类加载机制，保证实例的唯一性

  - 类加载过程:

    - 加载二进制数据到内存中，生成对应的Class数据结构
    - 连接：a.验证  b.准备（给类的静态成员变量赋默认值）  c.解析
    - 初始化: 给类的静态变量赋初值

  - 只有在真正使用对应的类时，才会触发初始化  如（当前类是启动类即main函数所在类，直接进行new操作，访问静态属性，访问静态方法，用反射访问类，初始化一个类的子类等等）

  - 代码

    ```java
    class HungrySingleton{
        private static HungrySingleton instance = new HungrySingleton();
        private HungrySingleton(){
        }
    
        public static HungrySingleton getInstance(){
            return instance;
        }
    }
    ```

- 静态内部类模式:

  - 本质上是利用类的加载机制来保证线程安全

  - 只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一种形式

  - 代码

    ```java
    class InnerclassSingleton{
        private static class InnerclassHolder{
            private static InnerclassSingleton instance = new InnerclassSingleton();
        }
    
        private InnerclassSingleton(){
        }
    
        public static InnerclassSingleton getInstance(){
            return InnerclassHolder.instance;
        }
    }
    
    ```

-  #### 枚举类型不支持反射

- #### 通过序列化和反序列化可以破坏单例模式

- ### 新课

  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- #### 设计模式常用的七大原则

  - 单一职责原则
  - 接口隔离原则
    - 一个类对另外一个类的依赖应该通过最小的接口
    - 可以通过对接口拆分去遵循原则
  - 依赖倒转原则
    - 面向接口编程
    - 模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
    - 接口或抽象类不依赖于实现类；
    - 实现类依赖接口或抽象类。
  - 里式替换原则
    - 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。
  - 开闭原则 ocp
  - 迪米特法则
  - 合成复用原则

- #### 单例设计模式一共有八种实现方式

  - 两种饿汉式
  - 两种懒汉式
  - 双重检查
  - 静态内部类
  - 枚举

- #### 依赖关系传递的三种方式

  - 接口传递
  - 构造方法传递
  - setter方式传递

- #### UML类图

  - https://www.jianshu.com/p/57620b762160

```java
//P16 0:00 ----2020年8月17日22:11:35
```

- #### 开闭原则

  - 对扩展开放（对提供方）
  - 对修改关闭（对使用方）
  - 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化

- #### 迪米特法则

  - 尽量将逻辑封装在类的内部，对外除了提供的public方法，不对外泄露任何信息
  - 只与直接的朋友通信
  - 直接朋友
    - B的实例对象是A的实例，则称B是A的直接朋友
    - A中有方法的参数包含B类型，则B是A的直接朋友
    - A中有方法的返回值类型为B，则B是A的直接朋友
  - 陌生的类最好不要以局部变量的形式出现在类的内部
  - 又叫最少知道原则

- #### 合成复用原则

  - 原则是尽量使用合成/聚成的方式，而不是使用继承
  - 能用 has a 就不用 is a

- #### UML类图

  - 推荐工具
    - rational rose

- #### 依赖关系

  - 只要是类中用到了对方，那么它们之间就存在依赖关系，如果没有对方，连编译都通过不了 

- #### 关联关系

  - 是依赖关系的特例
  - 类与类之间的联系
  - 具有导航型和多重性

- #### 聚合关系

  - 是关联关系的特例
  - 表示整体和部分的关系
  - 整体和部分可以分开
  - 具有导航型和多重性

- #### 组合关系

  - 也是整体与部分的关系
  - 但是整体和部分不能分离

- #### 设计模式三大类

  - 创建型模式
    - 单例模式
    - 抽象工厂模式
    - 原型模式
    - 建造者模式
    - 工厂模式
  - 结构型模式
    - 适配器模式
    - 桥接模式
    - 装饰模式
    - 组合模式
    - 外观模式
    - 享元模式
    - 代理模式
  - 行为型模式
    - 模板方法模式
    - 命令模式
    - 访问者模式
    - 迭代器模式
    - 观察者模式
    - 中介者模式
    - 备忘录模式
    - 解释器模式（Interpreter模式）
    - 状态模式
    - 策略模式
    - 职责链模式（责任链模式）

- #### 设计模式的本质：提高软件的维护性，通用性和扩展性，并降低软件的复杂度

- ### 创建型模式------------

- #### 八种单例设计模式

  - 饿汉式（静态常量）
  - 饿汉式（静态代码块）
  - 懒汉式（线程不安全）
  - 懒汉式（线程安全，同步方法）
  - 懒汉式（线程安全，同步代码块）
  - 双重检查
  - 静态内部类
  - 枚举

- #### 饿汉式

  - 构造器私有化

  - 向外暴露一个静态的公共方法，getInstance()

  - 利用类加载机制避免线程安全问题

  - 可能造成内存浪费

  - ##### 利用静态变量

    - 类的内部创建对象（private final static）

    ```java
    public class HungryMan1 {
    
        private static final HungryMan1 instance = new HungryMan1();
    
        private HungryMan1(){
    
        }
    
        public static HungryMan1 getInstance(){
            return HungryMan1.instance;
        }
    
    }
    ```

    

  - ##### 利用静态代码块

    - 在静态代码块中创建单例对象

    ```java
    public class HungryMan2 {
        private static final HungryMan2 instance;
        
        static{
            instance = new HungryMan2();
        }
    
        private HungryMan2(){
    
        }
    
        public static HungryMan2 getInstance(){
            return HungryMan2.instance;
        }
    }
    
    ```

    

- #### 懒汉式

  - 提供一个静态的公共方法，当使用该方法时，才去创建instance

  - 懒加载效果

  - 实际开发中不可以使用

  - 线程不安全式

    ```java
    public class LazyMan1 {
        private static LazyMan1 instance;
    
        private LazyMan1(){
    
        }
    
        public static LazyMan1 getInstance(){
            if(instance == null){
                instance = new LazyMan1();
            }
            return LazyMan1.instance;
        }
    }
    ```

  - 线程安全式，同步方法

    - 效率很低

    ```java
    public class LazyMan2 {
        private static LazyMan2 instance;
        
        private LazyMan2(){
            
        }
        
        public static synchronized LazyMan2 getInstance(){
            if(instance == null){
                instance = new LazyMan2();
            }
            return instance;
        }
    }
    ```

  - 同步代码块

    - 线程并不安全，只是白忙活

    ```java
    public class LazyMan3 {
        private static LazyMan3 instance;
    
        private LazyMan3(){
    
        }
    
        public static LazyMan3 getInstance(){
            if(instance == null){
                synchronized (LazyMan3.class){
                    instance = new LazyMan3();
                }
            }
            
            return instance;
        }
    }
    ```

    

- #### DoubleCheck

  - 既能解决线程安全问题又能减轻效率问题

  - volatile关键字

    - 能让修改值立即更新到主存
    - 可以立即从主存中获取值
    - 更新工作内存的值
    - 防指指令重排

    ```java
    public class DoubleCheck {
        private static volatile DoubleCheck instance;
    
        private DoubleCheck(){
    
        }
    
        public static DoubleCheck getInstance(){
            if(instance == null){
                synchronized (DoubleCheck.class){
                    if(instance == null){
                        instance = new DoubleCheck();
                    }
                }
            }
    
            return instance;
        }
    }
    
    ```

    

- #### 静态内部类实现单例

  - 类装载的时候其中的静态内部类不会被立即装载

  - 类装载的时候线程是安全的

    ```java
    public class StaticClass {
    
        private StaticClass(){
    
        }
    
        private static class StaticInnerClass{
            private static StaticClass instance = new StaticClass();
        }
    
        public static StaticClass getInstance(){
            return StaticInnerClass.instance;
        }
    }
    ```

    

- #### 枚举实现单例

  - 不仅能避免多线程同步问题，还能防止反序列化重新创建新的对象

  - 推荐使用

    ```java
    public enum EnumTemp {
        INSTANCE;
        public static void say(){
            System.out.println("说话");
        }
    }
    
    ```

```java
//P40 0:00 ----2020年8月18日18:17:53
```



- #### 简单工厂模式

  - 是由一个工厂对象决定创建出哪一种产品类的实例
  - 是工厂模式家族中最简单最实用的模式
  - 也叫静态工厂模式
  
- #### 工厂方法模式

  - 定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类，让子类自行依赖

```java
//P45 0:00 ----2020年8月18日23:55:16
```

- #### 抽象工厂模式

  - 定义一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
  - 可以将简单工厂模式和工厂方法模式进行整合
  - 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）
  - 将工厂抽象成两层，AbsFactroy(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类，这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展
  - 简单来说就是将接口聚合，利用多态生产不同的产品

- #### 尽量依赖抽象而不是细节



- #### 原型模式

  - 需要实现克隆的类必须实现Cloneable接口
  - 原型模式也叫Prototype模式
  - 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
  - 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型拷贝他们自己来实施创建，即 对象.clone()

- #### 深拷贝实现方式

  - 重写clone方法来实现深拷贝
  - 通过对象序列化来实现深拷贝（推荐）
    - 未必要写到硬盘中

- #### 建造者模式

  - 将产品和产品建造过程解耦
  - 也叫生成器模式
  - 将复杂对象的建造过程抽象出来（抽象类别），是这个抽象过程的不同实现方式可以构造出不同表现（属性）的对象
  - 一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节
  - 用户使用不同的建造者即可得到不同的产品对象
  - 指挥者面向抽象建造者
  - 核心的四个角色
    - Product(产品角色): 一个具体的产品对象
    - Builder(抽象建造者): 创建一个Product对象的各个部件指定的接口/抽象类
    - ConcreteBuilder(具体建造者): 实现接口，构建和装配各个部件
    - Director(指挥者): 构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象。主要有两个作用
      - 隔离客户与对象的生产过程
      - 负责控制产品对象的生产过程

```java
//建造者模式内容梳理到一半
```

- ### 结构型模式--------------

- #### 适配器模式

  - 也叫Adapter Pattern
  - 将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本接口不匹配不能一起工作的两个类可以协同工作
  - 别名为包装器
  - 主要分三类
    - 类适配器模式
    - 对象适配器模式
    - 接口适配器模式
  - 工作原理：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容
  - 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
  - 用户收到反馈结果，感觉只是和目标接口交互

- #### 类适配器

  - 基本介绍：Adapter类，通过继承src类，实现dst类接口，完成sr->dst的适配
  - 客户端依赖接口

- #### 对象适配器

  - 基本思路和类的适配器模式相同，只是将Adapter类做修改，不是继承src类，而是持有src类的实例（可以聚合），用以解决兼容性的问题
  - 即：持有src类，实现dst接口，完成src->dst的适配
  - 根据合成复用原则，在系统中尽量使用关联关系来替代继承关系

- #### 接口适配器

  - 也叫缺省适配器
  - 当不需要实现接口所有的方法时，可以先用一个抽象类将所有的方法实现，使用时只需要继承此抽象类再重写即可

```java
//64 8:52 ----2020年8月19日16:59:49
```

- #### 桥接模式

  - 将实现和抽象放在两个不同的类层次中，是两个层次可以独立改变
  - 也叫Bridge模式
  - 基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责，它的主要特点是把抽象与行为实现分离开，从而可以保持各部分的独立性以及应对他们的功能扩展
  - https://www.cnblogs.com/WindSun/p/10260547.html

```java
//71 0:00 ----2020年8月19日22:28:55
```

- #### 装饰者模式

  - 动态地将新功能附加到对象上，在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则
  - 装饰者模式就像打包一个快递
  - 一层包一层，最内层为被装饰者，其它层全为装饰者
  - 逆向思维，不把装饰者聚合到被装饰着，而是反过来

```java
//P74 30:00 ----2020年8月20日22:06:58
```



```java
//P77 10:08 ----2020年8月22日07:40:24
```

- #### 组合模式

  - 简化客户端操作，客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题
  - 具有较强的扩展性，当我们要更改组合对象时，只需要调整内部的层次关系，客户端不用做出任何改变
  - 方便创建出复杂的层次结构，客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
  - 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式
  - 要求较高的抽象性，如果节点和叶子有很多差异行的话，比如很多方法和属性都不一样，不适合使用组合模式
  - --- 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户可以使用一致的方法操作单个对象和组合对象。 --- 

- #### 外观模式（Facade）

  - 定义一个高层接口，给子系统中的一组接口提供一个一致的界面，用来访问子系统中的一群接口
  - 也就是说月通过定义一个一致的接口（界面类）,用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节
  - 也叫过程模式
  - 角色：
    - 外观类
      - 为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的请求代理给适当子系统对象
    - 调用者
      - 外观对象的调用者
    - 子系统的集合
      - 指模块或者子系统，处理外观类对象指派的任务，实际的功能实现者
      - 子系统之间的互相调用要封闭的实现，对外只暴露外观类
  - 通过合理的使用模式，可以帮我们更好地划分访问的层次

  - 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性
  - 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的

- #### 享元模式（Flyweight Pattern ）

  - 也叫蝇量模式
  - 运用共享技术有效的支持大量细粒度的对象
  - 常用于系统底层开发，解决系统的性能问题
  - 享元模式能够解决重复对象的内存浪费问题
  - 享元模式经典的应用场景就是池技术
  - 角色
    - FlyWeight
      - 抽象的享元角色
      - 是产品的抽象类
      - 同时定义出对象的外部状态和内部状态的接口或实现
        - 内部状态：对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
        - 外部状态：对象得以依赖的一个标记，是随环境改变而改变的，不可共享的状态
    - ConcreteFlyWeight
      - 具体的享元角色
      - 具体的产品类
      - 实现抽象角色定义相关业务
    - UnSharedConcreteFlyWeight
      - 是不可共享的角色
      - 一般不会再出现在享元工厂
    - FlyWeightFactory
      - 享元工厂类
      - 用于构建一个池容器
    - 在这里享元工厂是享元模式的核心，它需要确保系统可以共享相同的对象。它会维护一个对象列表，当我们想要获取享元类时，如果请求的享元类已经被创建，则直接返回已有的享元类：若没有，则创建一个新的享元对象，并将它加入到维护队列中
  - 博客url:https://baijiahao.baidu.com/s?id=1639843210271222415&wfr=spider&for=pc

```java
//87 13:00 ----2020年8月22日11:13:49
```

- #### 代理模式

  - 为一个对象提供一个替身，以控制对这个对象的访问
  - 即通过代理对象访问目标对象，这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能
  - 被代理的对象可以是远程对象、创建开销大的对象或者需要安全控制的对象
  - 有不同的形式
    - 静态代理
    - 动态代理（JDK代理、接口代理）
    - Cglib代理（可以在内存动态的创建对象，而不需要实现接口，属于动态代理）

- #### 静态代理

  - 在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类，然后代理对象通过父类或者父接口将被代理对象聚合
  - 优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展
  - 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类
  - 一旦接口增加方法，目标对象与代理对象都要维护

```java
//92 0:00 ---2020年8月22日20:06:36
```



- #### 动态代理

  - 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能动态代理
  
  - 代理对象的生成，是利用JDK的API,动态的在内存中构建代理对象
  
  - 动态代理也叫做：JDK代理、接口代理
  
  - JDK中生成代理对象的API
  
    - 代理类所在包：java.lang.Proxy
  
    - JDK实现代理只需要使用newProxyInstance方法，但是该方法需要接收三个参数，完整的写法是：
  
      - static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHander h)
  
      - 参数说明
  
        - loader：指定当前目标对象使用的类加载器，获取加载器的方法固定
        - interfaces: 目标对象实现的接口类型，使用泛型方法确认类型
        - h: 事情处理，执行目标对象的方法时，会出发事情处理器方法，会把当前执行的目标对象方法作为参数传入
  
      - demo
  
        ```java
        A a = (A)Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces,new InvocationHandler(){
            @override
            public Object invoke(Object proxy,Method method,Object[] args){
                System.out.println("代理开始~~~~");
                object returnVal = method.invoke(target,args);//真正需要执行的方法
                return returnVal;
            }
        });
        //A 为被代理类必须实现的接口
        //a 为生成的代理对象
        //newProxyInterface方法执行结果需要强行转换成目标类型，目标类型为被代理类必须实现的接口
        //进行完上述步骤后，可以使用a.方法名(参数列表)的形式调用被代理者的几乎所有方法
        ```



- #### Cglib代理

  - 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可以使用目标对象子类来实现代理

  - 也叫做子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理

  - Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口。它广泛的被许多AOP的框架使用，例如Spring AOP,实现方法拦截

  - 在AOP编程中如何选择代理模式

    - 目标对象需要实现接口 则用JDK代理
    - 目标对象不需要实现接口，则用Cglib代理

  - Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类

  - 使用步骤

    - 引入cglib的jar文件

      - asm.jar
      - asm-commons.jar
      - asm-tree.jar
      - cglib-2.2.jar

    - 在内存中动态创建子类，注意代理的类不能为final,否则会报错

      - java.lang.IllegalArgumentException

    - 目标对象的方法如果为final/static，那么就不会被拦截，既不会执行目标对象额外的业务方法

    - 创建代理类A实现MethodInterceptor接口

    - 将被代理类B聚合到代理A中,通常通过构造器传入

    - A需要重写getProxyInstance方法，使其返回一个代理对象，在这个方法中：

      - 创建一个工具类

        ```java
        Enhancer enhancer = new Enhancer();
        ```

      - 设置其父类

        ```java
        enhancer.setSuperclass(target.getClass());//target为B的实例
        ```

      - 设置回调函数

        ```java
        enhancer.setCallback(this);
        ```

      - 创建子类对象，即代理对象

        ```java
        return enhancer.create();
        ```

    - A还需要重写intercept方法，会调用目标的方法

      ```java
      public Object intercept(Object arg0,Method arg1,Object[] arg2,MethodProxy arg3) throws Throwable{
          ...
          Object returnVal = method.invoke(target,args);
          ...
          return returnVal;
      }
      ```

      

- #### 代理模式变体

  - 防火墙代理
    - 内网通过代理穿透防火墙，实现对公网的访问
  - 缓存代理
    - 比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok,否则到公网或者数据库去取
  - 远程代理
    - 远程对象的本地代表，通过它可以把远程对象当本地对象来调用。通过网络和真正的远程对象沟通信息
  - 同步代理
    - 主要是用在多线程编程中，完成多线程间同步工作

- ### 行为型模式---------------------------------

- #### 模板模式（Template Method Pattern）
  - 又叫模板模式
  - 在一个抽象类公开定义了他的方法的模板
  - 它的子类可以按需重写方法实现，但调用将以抽象类中定义的方式进行
  - 简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤
  - 钩子方法：
    - 在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为钩子

```java
//99 0:00 ----2020年8月23日00:37:04
```



- #### 命令模式（Command Pattern）

  - 将“动作的请求者”从“动作的执行者”对象中解耦出来
  - 在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是哪个
  - 我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用过命令模式来设计
  - 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦
  - 在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命令），同时命令模式也支持可撤销的操作
  - 角色
    - Invoker: 调用者
    - Receiver: 被调用者
    - MyCommand：命令，实现了Command接口，持有接收对象
    - Command: 命令的抽象
  - 命令对象将会把被调用者（接收者）聚合

```java
//P104 03:57 ----2020年8月23日09:59:47
```

- #### 访问者模式（Visitor Pattern）

  - 封装一些作用于某种数据结构的各元素的操作，可以在不改变数据结构的前提下定义作用于这些元素的操作
  - 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题
  - 基本工作原理：在被访问的类里面加一个对外提供接待访问者的接口
  - 主要应用场景：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式解决
  - 角色：
    - Visitor :抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作
    - ConcreteVisitor: 是一个具体的访问者，实现每个有Visitor声明的操作，是每个操作实现的部分
    - ObjectStructure: 能枚举他的元素，可以提供一个高层的接口，用来允许访问者访问元素
    - Element: 定义一个accept方法，接收一个访问者对象
    - ConcreteElement: 为具体元素，实现了accept方法
    - ![image-20200823134352156](D:\notes\随笔\note-imgs\image-20200823134352156.png)

  #### 


```java
//P111 03:50 ----2020年8月23日14:35:26
```

- #### 迭代器模式（Iterator Pattern）

  - 如果我们的集合元素使用不同的方式实现的，有数组，还有java的集合类或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决
  - 迭代器模式提供一种遍历集合的统一接口，用一致的方法遍历元素，不需要知道集合对象的底层表示，不暴露其内部结构
  - 针对不同的集合类型创建不同的迭代器对象，再使用迭代器的抽象类型接收并使用
  - 迭代器接口包含
    - boolean hasNext()
    - E next()
    - void remove()
  - 迭代器工厂接口包含
    - Iterator createIterator()
  - 迭代器工厂实现类包含
    - SetType eles属性

- #### 观察者模式

  - 

```java
//P117 03:06 ----2020年8月24日21:32:05
```

