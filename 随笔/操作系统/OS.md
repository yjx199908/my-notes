- #### 用户接口

  - 命令接口：
    - 联机命令接口：
      - 用户说一句，系统做一句
    - 脱机命令接口：
      - 用户说一堆，系统做一堆
  - 程序接口：只能通过程序调用的接口，调用程序接口的过程称为系统调用
    - 由一组系统调用组成
    - 用户只能通过使用应用程序间接使用
  - 一般 程序接口=系统调用
  - 易记浑的概念：
    - 系统调用=系统调用命令=广义指令

- #### GUI

  - 图形化用户界面

- ##### 通常把覆盖了软件的机器称为扩充机器或者虚拟机

- #### 操作系统的特征

  - 并发（*）

  - 共享（*）

    - 互斥共享：两个进程不能同时使用
    - 同时共享：可以微观上或宏观上同时使用

  - 虚拟

    - 时分复用
    - 空分复用

  - 异步

  - ##### 并发和共享互为存在特征

- ##### 操作系统在多道批处理时期诞生

- #### 阶段与分类

  - 手工操作阶段
    - 问题：
      - 人机速度不匹配
      - 用户独占全机
      - 一次只能运行一道程序
      - 人机无交互
  - 单道批处理系统
    - 引入脱机输入输出技术
    - 引入监督技术（操作系统的雏形）
    - 缓解了一部分人机速度不匹配的问题
    - 问题：
      - 用户独占全机
      - 一次只能运行一道程序
      - 人机无交互
  - 多道批处理系统
    - 每次往内存中输入多道程序
    - 多道程序并发执行
    - 需要中断技术支持并发
    - 操作系统同时正式诞生
    - 问题：
      - 人机无交互
      - 用户响应长
  - 分时操作系统
    - 计算机以时间片为单位轮流为每个用户提供服务
    - 解决了人机交互问题
    - 问题：
      - 不能优先处理一些紧急任务
  - 实时操作系统
    - 能够优先响应一些紧急任务
    - 某些紧急任务不需要时间片排队
    - 受到外部信号后及时处理
    - 在严格要求的时限内处理完事件
    - 主要特点是及时性和可靠性
    - 又分为
      - 硬实时操作系统
      - 软实时操作系统

- ##### 指令是处理器（CPU）能识别的最基本的命令

- #### 指令

  - 特权指令
    - 不允许普通用户使用
  - 非特权指令

- #### CPU如何判断当前是否可以执行特权指令

  - 两种处理器状态

    - 用户态（目态）

      - 只能执行非特权指令

    - 核心态（管态）

      - 特权和非特权指令都可以执行

    - ##### 两种状态使用程序状态字寄存器（PSW）中的某标志位来标识当前属于什么状态（例如0为用户态，1为核心态）

- #### 程序分为两种

  - 内核程序
    - 运行在核心态
    - 是系统的管理者
    - 可以执行特权指令和非特权指令
  - 应用程序
    - 运行在用户态
    - 只能执行非特权指令

- #### 操作系统层次结构

  ![image-20200902171851855](D:\notes\随笔\note-imgs\image-20200902171851855.png)

- #### 操作系统内核

  - 是计算机上的底层软件
  - 是操作系统最基本，最核心的部分
  - 实现操作系统内核功能的程序为内核程序
  - ![image-20200902172134668](D:\notes\随笔\note-imgs\image-20200902172134668.png)
  - 不同的操作系统内核划分可能不同

- #### 操作系统的体系结构

  - 大内核
    - 将操作系统的主要功能模块都作为系统内核，运行在核心态
    - 优点：高性能
    - 缺点：内核代码庞大，结构混乱，难以维护
  - 微内核
    - 只把最基本的功能保留在内核
    - 优点：内核功能少，结构清晰，方便维护
    - 缺点：需要频繁的在用户态和核心态之间切换，性能低

- ##### 发生中断意味着需要操作系统介入，开展管理工作

- #### 中断

  - 当中断发生时，CPU会立即进入核心态

  - 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理

  - 对于不同的中断信号，会进行不同的处理

  - 中断会使CPU由用户态切换为核心态，使操作系统获得计算机的控制权

  - 可以分为

    - 内中断（异常、例外、陷入）

      - 自愿中断（指令中断）
      - 强迫中断
        - 硬件故障
        - 软件中断

    - 外中断（中断）

      - ###### 狭义的中断

      - 外设请求

      - 人工干预

    - ##### 本质上的区别是中断信号是来源于CPU内部还是外部

- ##### 用户态到核心态的切换是通过中断来实现的，并且中断是唯一途径

- ##### 核心态到用户态的切换只需要使用一个特权指令将PSW上的标志位改为用户态标识即可

- #### 外中断处理过程

  - 执行完每个指令后，CPU都要检查当前是否有外部中断信号

  - 如果检测到外部中断信号，则需要保护被中断进程的CPU环境

    - 程序状态字（PSW）
    - 程序计数器（PC）
    - 各种通用寄存器
    - 等等

  - 根据中断信号类型转入相应的中断处理程序

    - ##### 中断处理程序在核心态

  - 恢复原进程的CPU环境并退出中断，返回原进程继续往下执行

- #### 系统调用

  - 系统中的各种各种共享资源都由操作系统统一掌管

  - 应用程序想要使用，必须向操作系统提出请求，再由操作系统代为完成

  - 这样可以保障系统的稳定性和安全性，防止用户进行非法操作

  - 可以协调各个请求

  - 凡是与资源有关的操作，会直接影响到其他进程的操作，一定需要操作系统介入，即需要系统调用来实现

  - 按功能分类

    - 设备管理
      - 完成设备的请求、释放、启动等功能
    - 文件管理
      - 完成文件的读写、创建、删除等功能
    - 进程控制
      - 完成进程的创建、撤销、阻塞、唤醒等功能

  - 进程通信

    - 完成进程之间的的消息传递、信号传递等功能

  - 内存管理

  - 完成内存的分配、回收等功能

  - ##### 需要在核心态完成

  - 和库函数的区别

    ![image-20200902180814536](D:\notes\随笔\note-imgs\image-20200902180814536.png)

    - 有的库函数涉及系统调用，而有的不涉及

```java
//P6 08:51 ----2020年9月2日18:09:52
```

- #### 系统调用大体步骤

  - 传递系统调用参数
  - 执行陷入指令（用户态）
  - 执行系统调用相应服务程序（核心态）
  - 返回用户程序

- ##### 陷入指令是在用户态执行的，会立即引发内中断，从而CPU进入核心态

- ##### 发出系统调用请求是在用户态进行，而对系统调用的处理是在核心态进行

- ##### 陷入指令是唯一一个只能在用户态执行，不能在核心态执行的指令

- #### 进程

  - 是系统进行资源分配和调用的一个独立单位

  - 进程的组成

    ![image-20200903102856653](D:\notes\随笔\note-imgs\image-20200903102856653.png)

- #### PCB

  - 进程控制块

  - 用来存放进程的各种信息（如程序代码存放位置）

  - 是进程存在的唯一标志

  - 创建一个进程实际上是创建一个PCB,撤销一个进程实际上也是撤销进程实体中的PCB

  - PCB中的信息

    ![image-20200903102613972](D:\notes\随笔\note-imgs\image-20200903102613972.png)

- #### 进程实体

  - 由PCB、程序段、数据段组成
  - 也叫进程映像
  - 简称为进程(但实际上两者并不相同)

- #### 进程与进程实体的区别

  - 进程实体是静态的，进程是动态的

- #### 进程的组织方式

  ![image-20200903103026126](D:\notes\随笔\note-imgs\image-20200903103026126.png)

  - 进程的链接组织方式

    ![image-20200903103206463](D:\notes\随笔\note-imgs\image-20200903103206463.png)

  - 进程的索引组织方式

    ![image-20200903103305249](D:\notes\随笔\note-imgs\image-20200903103305249.png)

- #### 进程的特征

  - 动态性
    - 最基本特征
    - 动态性是进程最基本的特性，可表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡，因而进程由一定的生命期
  - 并发性
  - 独立性
  - 异步性
  - 结构性

- #### 进程的状态与状态切换

  - 进程的三种基本状态

    ![image-20200903104636164](D:\notes\随笔\note-imgs\image-20200903104636164.png)

  - 另外两种状态

    - 创建态（新建态）
      - 操作系统创建进程，初始化PCB等，并将该进程所需要的资源分配给该进程
    - 终止态（结束态）
      - 操作系统将分配给该进程的资源回收，并撤销PCB等

  - 进程状态的转换

    ![image-20200903105518695](D:\notes\随笔\note-imgs\image-20200903105518695.png)

- #### 进程控制

  - 基本概念

    - 什么是进程控制
      - 主要功能是对系统中的所有进程实施有效的管理
      - 具有创建新进程，撤销已有进程，实现进程状态转换等功能
    - 如何实现进程控制
      - 使用原语实现
        - 防止进程控制指令不同步

  - 进程控制相关的原语

    - 进程的创建

      - 创建原语

        ![image-20200903110625890](D:\notes\随笔\note-imgs\image-20200903110625890.png)

    - 进程的终止

      - 撤消原语

        ![image-20200903110742848](D:\notes\随笔\note-imgs\image-20200903110742848.png)

    - 进程的阻塞

      - 阻塞和唤醒原语

        ![image-20200903110942671](D:\notes\随笔\note-imgs\image-20200903110942671.png)

    - 进程的唤醒

      - 唤醒原语：上图
      - 阻塞原语和唤醒原语要成对出现

    - 进程的切换

      - 切换原语

        ![image-20200903111124612](D:\notes\随笔\note-imgs\image-20200903111124612.png)

- ##### 原语是运行在核心态的，要一气呵成，不可中断

- #### 进程通信

  - 指进程之间的信息交换

  - 为了保证安全，一个进程不可以随意访问其他进程的地址空间

  - 共享存储

    - 基于数据结构的共享

    - 基于存储区的共享

    - 图解

      ![image-20200903112239573](D:\notes\随笔\note-imgs\image-20200903112239573.png)

  - 消息传递

    - 共同点

      消息体结构

      ![image-20200903113156373](D:\notes\随笔\note-imgs\image-20200903113156373.png)

    - 直接通信方式

      - 发送方进程创建格式化的消息体，然后通过发送原语将消息体挂到接收方的消息缓冲队列上
      - 接收方进程通过接收原语从消息缓冲队列上取下消息体

    - 间接通信方式

      - 消息体先发送到中间实体（信箱），因此也称为信箱通信方式

  - 管道通信

    - 图解

      ![image-20200903112542926](D:\notes\随笔\note-imgs\image-20200903112542926.png)

- #### 线程

  - 可以把线程理解为轻量级进程

  - 线城是一个基本的CPU执行单元，也是程序执行流的最小单位

  - 引入线程之后，不仅是进程之间可以并发，进程中的各线程之间也可以并发，进一步提高了系统的并发度，使得一个进程内也可以并发的执行多个任务

  - 引入线程之后，进程只作为除CPU之外的系统资源的分配单元

  - 带来的变化

    ![image-20200903114335508](D:\notes\随笔\note-imgs\image-20200903114335508.png)

  - 线程的属性

    ![image-20200903114610585](D:\notes\随笔\note-imgs\image-20200903114610585.png)

- #### 线程的实现方式

  - 用户级线程

    - 用户级线程由应用程序通过线程库实现

    - 所有的线程管理工作都由应用程序负责（包括线程切换）

    - 线程切换可以在用户态完成，无需操作系统干预

    - 在用户看来，是有多个线程。但在操作系统内核看来，意识不到线程的存在

    - 对用户不透明，对操作系统透明

    - 可以这样理解：用户级线程就是用户视角能看到的线程

    - 图解

      ![image-20200903114804105](D:\notes\随笔\note-imgs\image-20200903114804105.png)

  - 内核级线程

    - 又叫内核支持的线程，KLT

    - 内核级线程的管理工作由操作系统内核完成，线程切换和调度都由内核完成

    - 因此内核级线程的切换必然在核心态下完成

    - 可以这样理解：内核级线程就是从操作系统内核视角能看到的线程

    - 图解

      ![image-20200904090622175](D:\notes\随笔\note-imgs\image-20200904090622175.png)

  - 混合型线程实现方式

    - 在同时能支持内核级线程和用户级线程的操作系统中

    - 将n个用户级线程映射到m个内核级线程上（n>=m）

    - ##### 操作系统只能看的见内核级线程，因此内核级线程才是处理机分配的单位

      - 例如下图中有三个用户级线程被映射到两个内核级线程上，如果此进程在一个四核的计算机上运行，则此进程最多同时被分配到两个处理机上运行，而不是三个

    - 图解

      ![image-20200904091123251](D:\notes\随笔\note-imgs\image-20200904091123251.png)

    - 由混合型多线程实现方式引发的多线程模型分类

      - 多对一模型

        - 多个用户级线程映射到一个内核级线程
        - 每个进程对应一个内核级线程
        - 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的开销小，效率高
        - 缺点：当一个用户级线程被阻塞，整个进程都会被阻塞，并发性不高，多个线程不可以在多核处理机上并行运行
        - 图解

        ![image-20200904091623217](D:\notes\随笔\note-imgs\image-20200904091623217.png)

      - 一对一模型

        - 一个用户级线程映射到一个内核级线程

        - 每个用户进程有与用户级线程同等数量的内核级线程

        - 优点：当一个线程被阻塞后，别的线程还可以继续运行，并发能力强，多线程可以在多个处理机上同时运行

        - 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

        - 图解

          ![image-20200904092631566](D:\notes\随笔\note-imgs\image-20200904092631566.png)

      - 多对多模型

        - n用户级线程映射到m个内核级线程（n>=m）

        - 每个用户级线程映射到m个内核级线程

        - 优点：克服了多对一模型中并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核线程，开销太大的缺点

        - 图解

          ![image-20200904093224161](D:\notes\随笔\note-imgs\image-20200904093224161.png)

```java
//P11 11:23 ----2020年9月3日18:01:55
```

- #### 处理机调度

  - 就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

  - 知识体系图解

    ![image-20200904093658975](D:\notes\随笔\note-imgs\image-20200904093658975.png)

  - 三个层次

    - 高级调度

      - ##### 也叫作业调度 

      - 按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB）,以使他们获得竞争处理机的权利

      - 是外存和内存之间的调度

      - 调入时建立PCB,调出时撤销PCB,调入一次，调出一次

      - 高级调度主要是调入的问题，因为只有调入的时机由操作系统决定，调出的时机必然是作业结束才调出

    - 中级调度

      - ##### 也叫内存调度

      - ##### 中级调度就是要决定将哪个处于挂起状态的进程重新调入内存，一个进程可能发生多次中级调度，频率比高级调度高

      - 引入虚拟存储技术后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存

      - 目的是为了提高内存利用率和系统吞吐 量

      - ##### 暂时调到外存等待的进程状态称为挂起状态。

      - PCB并不会一起调到外存，而是会常驻内存，且PCB会记录进程数据在外存的存放位置，进程状态等信息

      - 操作系统会通过PCB来保持对各个进程的监控、管理

      - ##### 被挂起的进程PCB会被放入挂起队列

      - 挂起状态又分为就绪挂起和等待挂起

        - ##### 七状态模型

          ![image-20200904100049248](D:\notes\随笔\note-imgs\image-20200904100049248.png)

    - 低级调度

      - ##### 也叫进程调度

      - 主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它

      - 是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度

      - 频率很高，一般几十毫秒就会进行一次

    - 三种调度的联系，对比

      ![image-20200904100438765](D:\notes\随笔\note-imgs\image-20200904100438765.png)

- #### 进程调度的时机

  - 图解

    ![image-20200904101018414](D:\notes\随笔\note-imgs\image-20200904101018414.png)

  - 临界资源

    - 一个时间段内只允许一个进程使用的资源
    - 各进程需要互斥的访问临界资源

  - 临界区

    - 访问临界资源的那段代码
    - 分为
      - 普通临界区
        - 不会影响到操作系统内核的管理
        - 所以进程处于普通临界区的时候可以进行进程调度和切换
      - 内核程序临界区
        - 会影响到操作系统内核的管理
        - 所以进程处于普通临界取的时候不可以进行进程调度和切换

  - 内核程序临界区

    - 一般用来访问某种内核数据结构，比如进程的就绪队列

- #### 进程调度方式

  - ##### 非剥夺调度方式

    - 又叫非抢占式
    - 只允许进程主动放弃处理机
    - 在运行过程中即便有更紧急的任务到达，当前进程依然会继续占用处理机，直到该进程终止或主动要求进入阻塞态
    - 实现简单，系统开销小，但无法及时处理更紧急的任务，适合于早期的批处理系统

  - ##### 剥夺调度方式

    - 又叫抢占式
    - 可由操作系统剥夺当前进程的CPU使用权
    - 当一个进程在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要或更紧迫的那个进程
    - 可以优先的处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统，实时操作系统

  - 狭义的进程调度与进程切换的区别

    - 狭义的进程调度
      - 指的是从就绪队列中选中一个要执行的进程
      - 这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况需要进程切换
    - 进程切换
      - 指的是一个进程让出处理机，由另一进程占用处理机的过程

  - 广义的进程调度

    - 包含了一个选择一个进程和进程切换两个步骤

  - 进程切换

    - 主要完成
      - 对原来运行进程各种数据的保存
      - 对新的进程各种数据恢复（如程序计数器，程序状态字，各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）
    - 进程切换是有代价的，因此如果过于频繁的进行进程调度和进程切换，必然会是整个系统的效率降低，使系统大部分时间都花在进程切换上，而真正用于执行进程的时间减少

- #### 调度算法的评价指标

  - 图

    ![image-20200904110248778](D:\notes\随笔\note-imgs\image-20200904110248778.png)

  - CPU利用率

    - CPU忙碌的时间占总时间的比例

  - 系统吞吐量

    - 单位时间内完成作业的数量 （总共完成了多少道作业 / 总共花了多少时间）

  - 周转时间

    - 从作业被提交给系统开始，到作业完成为止的这段时间间隔

    - 包括四个部分

      - 作业在外存后备队列上等待被调度（高级调度）的时间

      - 进程在就绪队列上等待进程调度（低级调度）的时间

      - 进程在CPU上执行的时间

      - 进程等待I/O操作完成的时间

      - ###### 后三项在一个作业的整个处理过程中可能发生多次

      - ##### 周转时间 = 作业完成时间 - 作业提交时间

      - ##### 平均周转时间 = 全部作业周转时间之和 / 作业数

      - ##### 带权周转时间 = 作业周转时间 / 作业运行时间 = （作业完成时间 - 作业提交时间）/ 作业实际运行的时间

      - ##### 平均带权周转时间 = 各作业带权周转时间之和 / 作业数

  - 等待时间

    - 进程/作业处于等待处理机状态时间之和
    - 等待I/O设备的时间其实也是在被系统服务的，所以不计入等待时间

  - 响应时间

    - 从用户提交请求到首次产生响应所用的时间

- #### 调度算法

  - 各种算法学习思路图

  ![image-20200904112454893](D:\notes\随笔\note-imgs\image-20200904112454893.png)

  - 不适合交互式系统的调度算法
    - 先来先服务（FCFS）

  ![image-20200904113151507](D:\notes\随笔\note-imgs\image-20200904113151507.png)

  ​		- 短作业优先（SJF）

  ![image-20200904114146551](D:\notes\随笔\note-imgs\image-20200904114146551.png)

  ​		- 高响应比优先 （HRRN）

  ![image-20200904114746232](D:\notes\随笔\note-imgs\image-20200904114746232.png)

  ##### 	- 以上调度算法比较

  ![image-20200904131522270](D:\notes\随笔\note-imgs\image-20200904131522270.png)
  ​				这几种算法不关心响应时间，交互性也很差，适合于早期的批处理系统中，但FCFS也常结合其他算法使用

  - 适合交互式系统的调度算法

    - 时间片轮转调度算法

      - 默认新到达的进程先进入就绪队列

      - 如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为FCFS算法，并且会增大系统的响应时间，所以时间片不能太大

      - 如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间用于进程切换，从而导致实际用于进程执行的时间减少，可见时间片也不能太小

        ![image-20200904134028683](D:\notes\随笔\note-imgs\image-20200904134028683.png)

    - 优先级调度算法

      - 通常用户进程优先级低于系统进程优先级

      - 前台进程优先级高于后台进程优先级

      - 操作系统更偏好I/O型进程（又称为I/O繁忙型进程），与之相对的是计算型进程（又叫CPU繁忙型进程）

        - ###### 因为I/O设备是可以与CPU并行工作的，如果让I/O行进程优先运行，则有可能更早的让I/O设备投入工作，使得系统资源利用率，系统吞吐量都得到提高

      - 就绪队列未必只有一个

      - 根据优先级是否会动态改变

        - 静态优先级调度算法
          - 创建进程时确定优先级，之后不变
        - 动态优先级调度算法
          - 进程创建时有一个初始值，之后会根据情况动态地调整

      - 根据是否抢占式

        - 抢占式优先级调度算法
        - 非抢占式优先级调度算法

      - 分析图

        ![image-20200904140614997](D:\notes\随笔\note-imgs\image-20200904140614997.png)

    - 多级反馈队列调度算法

      ![image-20200904141355677](D:\notes\随笔\note-imgs\image-20200904141355677.png)


  ​			- 以上调度算法比较

  ​				![image-20200904141530679](D:\notes\随笔\note-imgs\image-20200904141530679.png)

- #### 进程同步

  - 同步也称为直接制约关系

  - 两种资源共享方式

    - 互斥共享方式

      - 系统的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源

      - 这种资源也称为临界资源，许多物理设备都属于临界资源

      - 对临界资源的访问，必须互斥地进行

      - ##### 互斥也称为间接制约关系

      - 对临界资源的访问逻辑上可以分为

        ![image-20200904155515105](D:\notes\随笔\note-imgs\image-20200904155515105.png)

        - 临界区是进程中负责访问资源的那段代码

        - 进入区和退出区是负责实现互斥的代码片段

        - 临界区也可称为临界段

        - ##### 为了实现对临界资源的互斥访问，需要遵循的原则

          ![image-20200904155837022](D:\notes\随笔\note-imgs\image-20200904155837022.png)

        - 几种进程互斥的软件实现算法

          - 单标志法

            ![image-20200904160542890](D:\notes\随笔\note-imgs\image-20200904160542890.png)

          - 双标志先检查法

            ![image-20200904161216697](D:\notes\随笔\note-imgs\image-20200904161216697.png)

          - 双标志后检查法

            ![image-20200904161526804](D:\notes\随笔\note-imgs\image-20200904161526804.png)

          - Peterson算法

            ![image-20200904162047552](D:\notes\随笔\note-imgs\image-20200904162047552.png)

            ##### 	用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是未遵循让权等待原则

          - 四种软件实现进程互斥的算法总结

            ![image-20200904162526194](D:\notes\随笔\note-imgs\image-20200904162526194.png)

        - 几种进程互斥的硬件实现方法

          - 中断屏蔽方法

            ![image-20200904163349130](D:\notes\随笔\note-imgs\image-20200904163349130.png)

          - TestAndSet方法（TS指令/TSL指令）

            ![image-20200904163840459](D:\notes\随笔\note-imgs\image-20200904163840459.png) 

          - Swap指令（XCHG指令、Exchange指令）

            ![image-20200904164137886](D:\notes\随笔\note-imgs\image-20200904164137886.png)

          - 几种硬件实现进程互斥的算法总结

            ![image-20200904164518571](D:\notes\随笔\note-imgs\image-20200904164518571.png)

    - 同时共享方式

      - 系统中的某些资源，允许一个时间段内有多个进程“同时”对他们进行访问

- ##### 开 / 关中断

  - ##### 关中断后不允许当前进程被中断，也不会发生进程切换

  - ##### 不适合多处理机，因为关中断只对执行关中断指令的处理机有效

  - ##### 属于特权指令

  - ##### 只适用于操作系统内核进程，不适用于用户进程（因为开 / 关中断指令只能运行在内核态，这组指令如果让用户随意使用会很危险）

```java
//P20 02:56 ----2020年9月4日16:51:00
```



- #### 信号量机制

  - 信号量就是一个变量，分为：

    - 整型信号量

      - 用一个整数表示系统中某一种资源的数量

      - 与普通整型变量不同的是，只能对整型信号量进行初始化、P、V操作

      - 功能用c语言表达为

        ```c++
        int S = 1;//整型信号量，表示现在系统中这种资源可用的数量
        
        void wait(int S){ //wait原语，相当于进入区
            while(S <= 0); //如果资源数不够，就一直循环等待
            S = S-1;       //如果资源数够，则占用一个资源
        }
        
        void signal(int S){ //signal原语，相当于“退出区”
            S = S+1;		//释放一个资源
        }
        ```

      - 使用时伪代码

        ```c
        //进程P0:
        ...
        wait(S);
        使用资源
        signal(S);
        ...
            
        //进程P1:
        ...
        wait(S);
        使用资源
        signal(S);
        ...
        
        //.....    
            
        //进程Pn:
        ...
        wait(S);
        使用资源
        signal(S);
        ...
        ```

      - 问题

      - 原语是不可中断的，如果一个进程进入wait原语并且系统中暂无可用资源，则会进入忙等状态，不满足让权等待

  - 记录性信号量

    - 定义了一个数据结构表示信号量

    - c语言表示

      ```c
      /*定义一个记录类型*/
      typedef struct{
          int value; //剩余资源数
          struct process *L; //等待队列
      }semaphore;
      
      //某进程需要使用资源时，需要通过此wait原语申请
      void wait(semaphore S){
          S.value--;
          if(S.value < 0){
              block(S.L); //如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把它挂到信号量S的等待队列中
          }
      }
      
      //某进程使用完资源后需要通过signal原语释放资源
      void signal(semaphore S){
          S.value++;
          if(S.value <= 0){
              wakeup(S.L);//如果释放资源后队列中还有别的进程在等待此资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
          }
      }
      ```

      

- 相关的一对源语（P、V操作）

  - wait(S)  P
  - signal(S)  V

- 信号量机制实现进程互斥

  - 分析并发进程的关键活动，划定临界区

  - 设置互斥信号量mutex,初值为一

  - c语言表达

    ```c
    semaphore mutex=1;
    
    P1(){
        ...
        P(mutex); //使用临界资源前需要加锁
        临界区代码段...
        V(mutext); //使用临界资源后需要解锁
        ...
    }
    
    P2(){
        ...
        P(mutex);
        临界区代码段...
        V(mutext);
        ...
    }
    ```

- 信号量机制实现进程同步

  - 在前操作之后执行V操作
  - 在后操作之前执行P操作

- 信号量机制实现前驱关系

  - 为每一对前驱关系设置一个同步变量

    ![image-20200906112548085](D:\notes\随笔\note-imgs\image-20200906112548085.png)

  - 在前操作之后对相应的同步变量执行V操作

  - 在后操作之前对相应的同步变量执行P操作

    ![image-20200906112808992](D:\notes\随笔\note-imgs\image-20200906112808992.png)

- 生产者与消费者问题

  - 将设置三个信号量

    - mutex :互斥信号量 使生产者与消费者互斥地访问资源
    - full: 同步信号量  产品数量
    - empty: 同步信号量   剩余空间数

  - 生产者与消费者的伪代码

    ![image-20200906115347383](D:\notes\随笔\note-imgs\image-20200906115347383.png)

    - 实现互斥的P操作一定要在实现同步的P操作之后

```java
//P23 0:00 ----2020年9月6日11:57:51 
```

- #### 多生产者与多消费者

  - 如果缓冲区大小为1，则有可能可以不设置互斥信号量
  - 否则，必须设置互斥信号量，因为如果两个生产者同时访问缓冲区，有可能发生数据覆盖的情况

- #### 管程

  - 是一种特殊的软件模块，组成：

    - 局部于管程的共享数据结构说明
    - 对该数据结构进行操作的一组过程
    - 对局部于管程的共享数据设置初始值的语句
    - 管程有一个名字

  - 基本特征

    - 局部于管城的数据只能被局部于管程的过程所访问
    - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    - 每次仅允许一个进程在管程内执行某个内部过程

  - 类C语言伪代码表示

    ![image-20200909161612948](D:\notes\随笔\note-imgs\image-20200909161612948.png)

  - 管程总结

    ![image-20200909162421272](D:\notes\随笔\note-imgs\image-20200909162421272.png)

- #### 死锁

  - 对不可剥夺的资源分配不合理的时候，可能导致死锁

  - 图解

    ![image-20200909164040516](D:\notes\随笔\note-imgs\image-20200909164040516.png)

  - 预防死锁

    ![image-20200909165908460](D:\notes\随笔\note-imgs\image-20200909165908460.png)

  - 避免死锁

    - 安全序列和安全状态
      - 就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，只要能找出一个安全序列，系统就是安全状态
      - 安全序列可能有多个
    - 不安全状态
      - 如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。
      - 意味着之后可能所有进程都无法顺利的进行下去。
      - 如果有一些进程提前归还了一些资源，那系统也有可能重新回到安全状态
    - 银行家算法核心思想
      - 在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源请求
      - ![image-20200909173406655](D:\notes\随笔\note-imgs\image-20200909173406655.png)

  - 死锁的检测

    ![image-20200909174059662](D:\notes\随笔\note-imgs\image-20200909174059662.png)

    - 资源分配图
      - 两种节点
        - 进程节点
        - 资源节点
      - 两种边
        - 进程节点--->资源节点：请求边
        - 资源节点--->进程节点：分配边

  - 死锁的解除

    ![image-20200909174609599](D:\notes\随笔\note-imgs\image-20200909174609599.png)

  - 死锁的检测和解除总结

    ![image-20200909175113128](D:\notes\随笔\note-imgs\image-20200909175113128.png)

```java
//P32 02:51 ----2020年9月9日18:10:07
```

- #### 写程序到程序运行的过程

  ![image-20200910092810779](D:\notes\随笔\note-imgs\image-20200910092810779.png)

- #### 程序装入内存的三种方式（逻辑地址到物理地址的转换）

  - 绝对装入

    - ![image-20200910093301993](D:\notes\随笔\note-imgs\image-20200910093301993.png)

  - 静态重定位

    - ![image-20200910101450867](D:\notes\随笔\note-imgs\image-20200910101450867.png)

  - 动态重定位

    - ![image-20200910103556977](D:\notes\随笔\note-imgs\image-20200910103556977.png)

  - ##### 模块链接的三种方式

    - 静态链接
      - 在程序装入之前，先将各目标模块及他们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开
    - 装入时动态链接
      - 将各目标的模块装入内存，边装入边链接的链接方式
    - 运行时动态链接
      - 在程序执行中需要改目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享

- #### 内存基础知识梳理

  ![image-20200910105213964](D:\notes\随笔\note-imgs\image-20200910105213964.png)

- #### 内存管理知识框架

  ![image-20200910110114400](D:\notes\随笔\note-imgs\image-20200910110114400.png)

- #### 实现内存扩充

  - 覆盖技术

    - 用途：用来解决程序大小超过物理内存总和的问题
    - 思想：将程序分为多个段，常用的段常驻内存，不常用的段在需要时调入内存
    - 内存中分为一个 **固定区** 和若干个 **覆盖区**
    - 需要常驻内存的段放在固定区，调入后在运行结束前不再调出，不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存
    - 按照自身逻辑结构，让那些不可能被同时访问的程序段共享同一个覆盖区
    - 缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖，对用户不透明，增加了用户编程负担。
    - 只用于早期操作系统中，现已成为历史

  - 交换技术

    - 设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存和磁盘间动态调度）

    - ###### 补充：暂时换到外存等待的进程状态称为挂起状态（挂起态：suspend）

    - 外存管理

      - 在具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分
      - 文件区主要用于存放文件，追求空间的利用率，所以空间的管理采用离散式分配。
      - 对换区空间只占磁盘空间的小部分，用于存放被换出的进程数据，追求换入换出速度，所以采用连续分配方式
      - 对换区的I/O速度比文件区要快
      
    - 处理思路：
    
      - 可优先换出阻塞进程
      - 可换出优先级低的进程
      - 以及考虑进程在内存中的驻留时间
    
    - ##### PCB常驻内存
    
  - 覆盖与交换技术小结梳理
  
  ![image-20200910130947949](D:\notes\随笔\note-imgs\image-20200910130947949.png)
  
  
  
- #### 内存空间的分配与回收

  - 连续分配管理方式

    - ##### 特点：系统为用户进程分配的必须是一个连续的内存空间

    - 分为

      - 单一连续分配

        ![image-20200910131755586](D:\notes\随笔\note-imgs\image-20200910131755586.png)

      - 固定分区分配

        - 分区大小相等

        - 分区大小不等

        - 某个分区一次只能分配给某个进程使用

        - 操作系统需要建立一个叫做分区说明表的数据结构，来实现各分区的分配与回收，每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的大小、起始地址、状态（是否已分配）

          - 分区说明表

            ![image-20200910132607104](D:\notes\随笔\note-imgs\image-20200910132607104.png)

        - 图解

          ![image-20200910132103426](D:\notes\随笔\note-imgs\image-20200910132103426.png)

      - 动态分区分配

        - 又称为可变分区分配

        - 不会预先划分内存分区，而是在进程装入内存时，根据内存的大小动态的建立分区，并使分区的大小正好适合进程的需要

        - 系统分区的大小和数目是可变的

        - 管理空闲分区的两种常用的数据结构

          - 空闲分区表

          - 空闲分区链

          - 图解

            ![image-20200910133252281](D:\notes\随笔\note-imgs\image-20200910133252281.png)

        - 没有内部碎片，但有外部碎片

      - ##### 知识点补充：碎片

        - 内部碎片：分配给某进程的内存区域中，有些部分没有用上

        - 外部碎片：内存中的某些空闲分区由于太小而难以利用

          - ##### 可以使用紧凑技术（Compaction）解决外部碎片，但是代价很高

      - 动态分区分配算法

        - 首次适应算法

          - 每次都从低地址开始查找，找到第一个能满足大小的空闲分区
          - 空闲分区以地址递增的次序排列，每次分配时顺序查找空闲分区链或空闲分区表

        - 最佳适应算法

          - 优先使用更小的空闲分区
          - 空闲分区按照容量递增的次序依次链接
          - 每次分配顺序查找空闲分区表或空闲分区链
          - 缺点：会留下越来越多的小的外部碎片

        - 最坏适应算法

          - 又称最大适应算法
          - 优先使用更大的空闲区
          - 空闲分区按照容量递减的次序进行链接
          - 每次分配顺序查找空闲分区表或空闲分区链

        - 邻近适应算法

          - 空闲分区以地址递增的顺序进行排列
          - 每次分配内存时从上次查找结束的位置开始查找空闲分区表或空闲分区链

        - 小结梳理

          ![image-20200910145234886](D:\notes\随笔\note-imgs\image-20200910145234886.png)

  - 非连续分配管理方式

    - 或称为离散分配方式

    - ##### 特点：为用户进程分配的可以是一些分散的内存空间

    - 分为

      - 基本分页存储管理

        - 将内存空间分为一个个大小相等的分区

        - 每个分区就是一个页框，或者成为页帧、内存块、物理块

        - 每个页框都有一个编号，即页框号（或者内存块号、页帧号、物理块号）

        - 页框号从0开始

        - 将用户进程的地址空间也分为也页框大小相等的一个个区域，成为“页”或“页面”

        - 每个页面也有一个编号，即“页号”

        - 页号也是从0开始

        - 操作系统以页框为单位为各个进程分配内存空间

        - 进程的每个页面会被放入一个页框里

        - 进程的页面和内存的页框有一一对应的关系

        - 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中

        - 实现地址转换的方法（图）

          ![image-20200910155553000](D:\notes\随笔\note-imgs\image-20200910155553000.png)、

        - 为了能知道进程的每个页面在内存中的存放位置，操作系统要为每个进程建立一张页表

          - 一个进程对应一张页表

          - 进程的每一个页对应一个页表项

          - 每个页表项由页号和块号组成

          - 页表记录进程页面和实际存放的内存块之间的对应关系

          - 块号*块的大小就是块的起始地址

          - ##### 每个页表项的长度是相同的，页号是隐含的

            - 各页表项会被按顺序连续地连续地存放在内存中
            - 只需要知道页表存放的起始地址和页表长度，即可找到各个页号对应的页表项存放的位置
            - 页表起始地址和页表长度是存放在PCB中的

        - 基本分页存储管理梳理

          ![image-20200910161629416](D:\notes\随笔\note-imgs\image-20200910161629416.png)

        - ##### 基本地址变换机构

          - 用于实现逻辑地址到物理地址转换的一组硬件机构

          - ![image-20200911083042637](D:\notes\随笔\note-imgs\image-20200911083042637.png)

          - 知识梳理

            ![image-20200911084242211](D:\notes\随笔\note-imgs\image-20200911084242211.png)

        - ##### 具有快表的地址变换机构

          - 是基本地址变换机构的改进版本

          - 局部性原理

            - 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，那么不久之后该条数据很有可能再次被访问（因为程序中存在大量循环）
            - 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的）

          - 快表

            - 又称为联想寄存器（TLB）
            - 是一种访问速度比内存快很多的高速缓冲存储器
            - 用来存放当前访问的若干页表项，以加速地址变换的过程
            - 与此对应，内存中的页表称为慢表

          - 添加快表之后的地址变换过程

            ![image-20200911085915950](D:\notes\随笔\note-imgs\image-20200911085915950.png)

          - 在快表中查询不到时就要到内存中查找，找到后将副本添加到快表中，如果快表已满，则需要使用一定的算法对快表中的页表项进行替换

        - ##### 两级页表

          - 单级页表的问题

            - 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框
            - 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面
            - 解决方案：
              - 可将长长的页表进行分组，使每个内存块刚好可以放入一个分组，再将各分组离散地放到各个内存块中
              - 另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表

          - 两级页表地址结构

            ![image-20200911093004307](D:\notes\随笔\note-imgs\image-20200911093004307.png)

```java
//P41 0:00 ----2020年9月11日09:48:56
```

