# -模块分为：

### 	+用户自己写的文件模块 :用require('文件a路径')引入并执行a的代码

### +第三方模块

### 	+具名的核心模块，例如http,fs等 :用require('模块名')引入

 

# -导出与导入

### 	+导出(在源文件中)

#### 		exports默认是一个空对象

#### 		添加导出项：exports.a(属性名)=需要导出的对象（变量/对象/方法）

```javascript
//导出一个或多个
exports.a = 123
exports.b = 'hello'
exports.c = function(){
    console.log('ccc')
}

exports.d = {
    foo:'bar'
}
```



```javascript
//导出单个对象
module.exports = {
    a:123,
    b:'hello',
    c:function(){
        console.log('ccc')
    }
}
```



### 	+导入(在此文件中)

#### 		let obj(自定义对象名)=require('原文件路径')

#### 		let b(自定义对象名) = obj.a



#### *node中没有全局作用域,，只有模块作用域*

#### *require引入时可以省略后缀名【.js/.node】*

#### *require相对路径的./不可以省略*

#### *require引入执行相当于把源文件的代码放到此文件来执行,所以要注意路径问题*





# require加载规则

- ##### 1.优先从缓存加载：*`加载过的模块(执行产生的接口)会留在缓存中，下次调用时从缓存获取`*

- ##### 2.判断模块标识符:

  - ##### 核心模块:

    - ###### `非路径形式的模块标识,`

    - ###### `核心模块的本质也是文件`

    - ###### `核心模块已经被编译到了二进制位文件中了，我们只需要按照名字来引用就可以了`

  - ##### 第三方模块

    - ###### `需要通过npm下载`

    - ###### `使用的时候就可以通过require('包名')的方式来进行加载使用`

    - ###### `不可能又任何一个第三方包和核心模块的名字一样`

    - ###### `非路径形式的模块标识`

    - ###### `require时先找所处目录下的node_modules目录,` 

      - ###### `如果有则查找有无与包同名的子目录,`

      - ###### `如果有,则继续查找此目录下有无package.json文件,`

      - ###### `如果有,则找main属性,main属性中记录了此包的入口模块`

      - ###### `如果没找到main或者main是错的或者没有package.json,则默认使用包目录下的index.js`

      - ###### `如果以上条件任何一条不成立,直到磁盘根目录下还找不到,则报错Can Not Find Module XXX`

      

  - ##### 自己写的模块

  - ###### *路径形式的模块标识符*

    ###### 1.首位如果是 '/',则这个 '/' 表示的是`当前文件模块所属磁盘根路径`

    ###### 2.首位的 './' 和 '../' 不可省略

    ###### 3.'.js','.node','.vue'后缀可以省略



